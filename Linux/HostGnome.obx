module HostGnome
	(* Version for Linux
	   This module initializes the Gtk environment, makes sure that all libraries are loaded in the correct order, and installes a message box hook in Kernel to allow graphical message boxes.
	   Any application using the graphical user interface on Linux must have this module linked. *)
	
	
	
	import SYSTEM, LinDl, Kernel
	
	type 
		Hook = pointer to record (Kernel.GuiHook) end 
		
		(* Gtk2 calls are implemented with procedure variables instead of interface modules to
		   be able to guarantee that libraries are loaded in the correct order. *)
		BeepType = proc 
		
		InitCheckType = proc (argc, argv: integer): integer
		
		GtkMessageDialogNewType = proc (parent: pointer to record end ; flags: set; type_, buttons: integer; in message_format: carray of char): integer
		
		GtkDialogRunType = proc (dlg: integer): integer
		
		GtkWidgetDestroyType = proc (dlg: integer)
		
		GtkWindowSetTitleType = proc (window: integer; title: unsafe pointer to carray of char)
	
	var 
		hook: Hook
		gdk_beep: BeepType
		gtk_init_check, gdk_init_check: InitCheckType
		gtk_dialog_run: GtkDialogRunType
		gtk_widget_destroy: GtkWidgetDestroyType
		gtk_message_dialog_new: GtkMessageDialogNewType
		gtk_window_set_title: GtkWindowSetTitleType
		dialogIsOpen*: boolean
	
	proc (h: Hook) Beep*
	begin 
		gdk_beep
	end Beep
	
	proc (h: Hook) MessageBox*(title, msg: array of char; buttons: set): integer 
		var 
			res, bt, dlg: integer // Gtk2Gtk.GtkMessageDialog
			uTitle, uMsg: array 1024 of char
	begin 
		Kernel.StringToUtf8(title, uTitle, res)
		Kernel.StringToUtf8(msg, uMsg, res)
		bt := 2 // close default
		if (Kernel.mbOk in buttons) & (Kernel.mbCancel in buttons) then
			bt := 5 
		elsif Kernel.mbOk in buttons then 
			bt := 1 
		elsif Kernel.mbCancel in buttons then 
			bt := 3 
		elsif (Kernel.mbYes in buttons) & (Kernel.mbNo in buttons) then 
			bt := 4 
		end 
		
		(* mbClose* = -1;
		   mbOk* = 0;
		   mbCancel* =1;
		   mbRetry* = 2;
		   mbIgnore* = 3;
		   mbYes* = 4;
		   mbNo* = 5;
		   
		   GTK_BUTTONS_NONE* =0;
		   GTK_BUTTONS_OK*=1;
		   GTK_BUTTONS_CLOSE*=2;
		   GTK_BUTTONS_CANCEL*=3;
		   GTK_BUTTONS_YES_NO*=4;
		   GTK_BUTTONS_OK_CANCEL*=5; *)
		
		
		
		dlg := gtk_message_dialog_new(nil, {0, 1}, 1, bt, uMsg)
		gtk_window_set_title(dlg, uTitle)
		dialogIsOpen := true
		res := gtk_dialog_run(dlg)
		dialogIsOpen := false
		gtk_widget_destroy(dlg)
		
		(* GTK_RESPONSE_NONE* = -1;
		   GTK_RESPONSE_REJECT* = -2;
		   GTK_RESPONSE_ACCEPT* = -3;
		   GTK_RESPONSE_DELETE_EVENT* = -4;
		   GTK_RESPONSE_OK*     = -5;
		   GTK_RESPONSE_CANCEL* = -6;
		   GTK_RESPONSE_CLOSE*  = -7;
		   GTK_RESPONSE_YES*    = -8;
		   GTK_RESPONSE_NO*     = -9;
		   GTK_RESPONSE_APPLY  = -10;
		   GTK_RESPONSE_HELP   = -11; *)
		
		
		
		case res of 
			| -5: 
				res := Kernel.mbOk 
			| -6: 
				res := Kernel.mbCancel 
			| -7: 
				res := Kernel.mbClose 
			| -8: 
				res := Kernel.mbYes 
			| -9: 
				res := Kernel.mbNo 
		else 
			res := Kernel.mbClose 
		end 
		return res
	end MessageBox
	
	proc Init
		var 
			res, adr: integer
			ok: boolean
			h1, h2, h3: LinDl.HANDLE
			pad0, pad1: integer
	begin 
		h1 := LinDl.dlopen("libgtk-x11-2.0.so.0", LinDl.RTLD_LAZY + LinDl.RTLD_GLOBAL)
		h2 := LinDl.dlopen("libgdk-x11-2.0.so.0", LinDl.RTLD_LAZY + LinDl.RTLD_GLOBAL)
		h3 := LinDl.dlopen("libglib-2.0.so.0", LinDl.RTLD_LAZY + LinDl.RTLD_GLOBAL)
		if h1 = 0 then
			res := Kernel.MessageBox("BlackBox", 
				"HostGnome: can not load libgtk-x11-2.0.so.0", {Kernel.mbOk}) 
		elsif h2 = 0 then 
			res := Kernel.MessageBox("BlackBox", 
				"HostGnome: can not load libgtk-x11-2.0.so.0", {Kernel.mbOk}) 
		elsif h3 = 0 then 
			res := Kernel.MessageBox("BlackBox", 
				"HostGnome: can not load libglib-2.0.so.0", {Kernel.mbOk}) 
		else 
			adr := LinDl.dlsym(h1, "gtk_init_check")
			if adr # 0 then
				gtk_init_check := SYSTEM.VAL(InitCheckType, adr) 
			end 
			adr := LinDl.dlsym(h1, "gtk_message_dialog_new")
			if adr # 0 then
				gtk_message_dialog_new := SYSTEM.VAL(GtkMessageDialogNewType, adr) 
			end 
			adr := LinDl.dlsym(h1, "gtk_dialog_run")
			if adr # 0 then
				gtk_dialog_run := SYSTEM.VAL(GtkDialogRunType, adr) 
			end 
			adr := LinDl.dlsym(h1, "gtk_widget_destroy")
			if adr # 0 then
				gtk_widget_destroy := SYSTEM.VAL(GtkWidgetDestroyType, adr) 
			end 
			adr := LinDl.dlsym(h1, "gtk_window_set_title")
			if adr # 0 then
				gtk_window_set_title := SYSTEM.VAL(GtkWindowSetTitleType, adr) 
			end 
			adr := LinDl.dlsym(h2, "gdk_beep")
			if adr # 0 then
				gdk_beep := SYSTEM.VAL(BeepType, adr) 
			end 
			adr := LinDl.dlsym(h2, "gdk_init_check")
			if adr # 0 then
				gdk_init_check := SYSTEM.VAL(InitCheckType, adr) 
			end 
			
			if (gtk_init_check # nil) & (gdk_init_check # nil) then
				res := gtk_init_check(SYSTEM.ADR(Kernel.argc), SYSTEM.ADR(Kernel.argv))
				if res = 0 then
					res := Kernel.MessageBox("BlackBox", "gtk init error", {Kernel.mbOk}) 
				end 
				res := gdk_init_check(SYSTEM.ADR(Kernel.argc), SYSTEM.ADR(Kernel.argv))
				if res = 0 then
					res := Kernel.MessageBox("BlackBox", "gdk init error", {Kernel.mbOk}) 
				end 
				new(hook)
				Kernel.SetGuiHook(hook)
				// re-install signals
				Kernel.InstallSignals 
			else 
				res := Kernel.MessageBox("BlackBox", 
					"HostGnome: init procedures did not found in gtk and gdk libraries", {Kernel.mbOk}) 
			end  
		end 
	end Init

begin
	Init
end HostGnome
