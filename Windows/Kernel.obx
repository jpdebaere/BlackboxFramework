module Kernel
	(* project	= "BlackBox"
	   organization	= "www.oberon.ch"
	   contributors	= "Oberon microsystems"
	   version	= "System/Rsrc/About"
	   copyright	= "System/Rsrc/About"
	   license	= "Docu/BB-License"
	   changes	= "##=>
	   
	   - 20070123, bh, Beep using MessageBeep
	   - 20070125, bh, Support for procedure signatures added
	   - 20070130, bh, KERNEL32 & USER32 eliminated
	   - 20070220, bh, comSig eliminated
	   - 20070307, bh, improved Ctrl-Break handling
	   - 20070308, bh, check for unloaded module in ExecFinalizer
	   - 20080107, bh, full GC included in NewBlock
	   - 20080107, bh, pointer anchoring bug corrected in NewRec & NewArr
	   - 20120822, bh, mf, checks for integer overflow in NewArr and NewBlock
	   - 20120906, luowy, deallocate cluster only if dllMem
	   - 20120906, luowy, correction in free list initialization
	   - 20130824, luowy, additional (b = NIL) checks in NewBlock
	   - 20141027, center #19, 16-bit Unicode support for Component Pascal identifiers added
	   - 20141027, center #25, fixing a bug in stack overflow handling
	   - 20150306, center #30, fixing Kernel.IsAlpha for Japanese Hiragana and Katakana
	   - 20151027, center #80, support for qualified names fixed in SplitName
	   - 20160315, center #109, Bounds checking in Kernel.MakeFileName
	   - 20160321, center #108, initialize WinApi controls for correct errors messages in XP
	   - 20161122, center #143, inconsistent module list when CLOSE loads itself indirectly
	   - 20170309, center #149, bug in Kernel.Upper/Lower
	   - 20170321, center #156, adding Coroutines to BlackBox
	   - 20181111, center #190, add comment about stack and heap memory configuration
	   - 20181123, center #192, Kernel.Call does not work with ANYREC-parameters
	   - 20181213, center #194, Meta.PutParam and Kernel.Call for open arrays are mismatched
	   ##<="
	   issues	= "##=>
	   
	   - ...
	   ##<=" *)
	
	
	
	
	// green color means COM-specific code
	
	import S:= SYSTEM, COM, WinApi, WinOle
	
	const 
		strictStackSweep = true
		
		nameLen* = 256
		
		littleEndian* = true
		timeResolution* = 1000 // ticks per second
		
		processor* = 10 // i386
		
		objType* = "ocf" // file types
		symType* = "osf"
		docType* = "odc"
		
		// loader constants
		done* = 0
		fileNotFound* = 1
		syntaxError* = 2
		objNotFound* = 3
		illegalFPrint* = 4
		cyclicImport* = 5
		noMem* = 6
		commNotFound* = 7
		commSyntaxError* = 8
		moduleNotFound* = 9
		
		any = 1000000
		
		CX = 1
		SP = 4 // register number of stack pointer
		FP = 5 // register number of frame pointer
		ML = 3 // register which holds the module list at program start
		
		N = 128 div 16 // free lists
		
		// kernel flags in module desc
		init = 16
		dyn = 17
		dll = 24
		iptrs = 30
		
		// meta interface consts
		mConst = 1
		mTyp = 2
		mVar = 3
		mProc = 4
		mField = 5
		
		debug = false
	
	
	type 
		Name* = array nameLen of wchar
		Utf8Name* = array nameLen of char
		Command* = proc 
		
		Module* = unsafe pointer to cstruct 
				next-: Module
				opts-: set // 0..15: compiler opts, 16..31: kernel flags
				refcnt-: integer // <0: module invalidated
				compTime-, loadTime-: carray 6 of shortint
				ext-: integer // currently not used
				term-: Command // terminator
				nofimps-, nofptrs-: integer
				csize-, dsize-, rsize-: integer
				code-, data-, refs-: integer
				procBase-, varBase-: integer // meta base addresses
				names-: unsafe pointer to carray of char // names[0] = 0X
				ptrs-: unsafe pointer to carray of integer
				imports-: unsafe pointer to carray of Module
				export-: Directory // exported objects (name sorted)
				name-: carray nameLen of char // Utf8Name 
			end 
		
		Type* = unsafe pointer to cstruct 
				// record: ptr to method n at offset - 4 * (n+1)
				size_-: integer // record: size, array: #elem, dyn array: 0, proc: sigfp
				mod_-: Module
				id-: integer // name idx * 256 + lev * 16 + attr * 4 + form
				base-: carray 16 of Type // signature if form = ProcTyp
				fields-: Directory // new fields (declaration order)
				ptroffs-: carray any of integer  // array of any length
			end 
		
		Object* = unsafe pointer to ObjDesc
		
		ObjDesc* = cstruct 
				fprint-: integer
				offs-: integer // pvfprint for record types
				id-: integer // name idx * 256 + vis * 16 + mode
				struct-: Type  // id of basic type or pointer to typedesc/signature
			end 
		
		Directory* = unsafe pointer to cstruct 
				num-: integer // number of entries
				obj-: carray any of ObjDesc  // array of any length
			end 
		
		Signature* = unsafe pointer to cstruct 
				retStruct-: Type // id of basic type or pointer to typedesc or 0
				num-: integer // number of parameters
				par-: carray any of cstruct  // parameters
						id-: integer // name idx * 256 + kind
						struct-: Type  // id of basic type or pointer to typedesc
					end  
			end 
		
		Handler* = proc 
		
		Reducer* = pointer to (* abstract *) record 
				next: Reducer 
			end 
		
		Identifier* = (* abstract *) record 
				typ*: integer
				obj-: ANYPTR 
			end 
		
		TrapCleaner* = pointer to (* abstract *) record 
				next: TrapCleaner 
			end 
		
		TryHandler* = proc (a, b, c: integer)
		
		
		// meta extension suport
		
		ItemExt* = pointer to (* abstract *) record end 
		
		ItemAttr* = record 
				obj*, vis*, typ*, adr*: integer
				mod_*: Module
				desc*: Type
				ptr*: S.PTR
				ext*: ItemExt 
			end 
		
		Hook* = pointer to (* abstract *) record end 
		
		LoaderHook* = pointer to (* abstract *) record (Hook) 
				res*: integer
				importing*, imported*, object*: array 256 of wchar 
			end 
		
		Block = unsafe pointer to cstruct 
				tag: Type
				last: integer // arrays: last element
				actual: integer // arrays: used during mark phase
				first: integer  // arrays: first element
			end 
		
		FreeBlock = unsafe pointer to FreeDesc
		
		FreeDesc = cstruct 
				tag: Type // f.tag = ADR(f.size)
				size_: integer
				next: FreeBlock 
			end 
		
		Cluster = unsafe pointer to cstruct 
				size_: integer // total size
				next: Cluster
				max_: integer  // exe: reserved size, dll: original address
			// start of first block
			end 
		
		FList = pointer to record 
				next: FList
				blk: Block
				iptr, aiptr: boolean 
			end 
		
		CList = pointer to record 
				next: CList
				do_: Command
				trapped: boolean 
			end 
		
		
		PtrType = record v: S.PTR end  // used for array of pointer
		Char8Type = record v: char end 
		Char16Type = record v: wchar end 
		Int8Type = record v: byte end 
		Int16Type = record v: shortint end 
		Int32Type = record v: integer end 
		Int64Type = record v: longint end 
		BoolType = record v: boolean end 
		SetType = record v: set end 
		Real32Type = record v: real end 
		Real64Type = record v: longreal end 
		ProcType = record v: proc  end 
		UPtrType = record v: integer end 
		IntPtrType = record p: COM.IUnknown end  // used for array of interface pointer
		
		StrPtr = unsafe pointer to carray of char
		
		IntPtr = unsafe pointer to cstruct p: COM.IUnknown end 
		
		Interface = pointer to record  // COMPILER DEPENDENT
				vtab: integer
				ref: integer // must correspond to Block.actual
				unk: COM.IUnknown 
			end 
		
		
		// Exception handling
		
		ExcpFramePtr* = unsafe pointer to ExcpFrame
		ExcpFrame* = (* extensible *) cstruct 
				link*: ExcpFramePtr
				handler*: proc (excpRec: WinApi.PtrEXCEPTION_RECORD
					estFrame: ExcpFramePtr
					context: WinApi.PtrCONTEXT
					dispCont: integer): integer 
			end 
		ComExcpFramePtr = pointer to record (ExcpFrame) 
				par: integer 
			end 
		
		Coroutine* = pointer to CoroutineDesc
		CoroutineDesc = record 
				prev, next: unsafe pointer to CoroutineDesc // circular list
				fiber: WinApi.PtrVoid
				stackBase, stackTop: integer // stackBase = 0 means not yet started
				trapStack: TrapCleaner
				trapChecker: Handler
				stackChecked: boolean 
			end 
	
	var 
		baseStack: integer // modList, root, and baseStack must be together for remote debugging
		root: Cluster // cluster list
		modList-: Module // root of module list
		trapCount-: integer
		err-, pc-, sp-, fp-, stack-, val_-: integer
		mainWnd*: integer
		
		free: array N of FreeBlock // free list
		sentinelBlock: FreeDesc
		sentinel: FreeBlock
		candidates: array 1024 of integer
		nofcand: integer
		allocated: integer // bytes allocated on BlackBox heap
		total: integer // current total size of BlackBox heap
		used: integer // bytes allocated on system heap
		finalizers: FList
		hotFinalizers: FList
		cleaners: CList
		reducers: Reducer
		trapStack: TrapCleaner
		actual: Module // valid during module initialization
		
		res: integer // auxiliary global variables used for trap handling
		old: integer
		
		trapViewer, trapChecker: Handler
		trapped, guarded, secondTrap: boolean
		interrupted: boolean
		static, inDll, dllMem, terminating: boolean
		retAd: integer
		restart: Command
		
		heap: WinApi.HANDLE
		excpPtr: ExcpFramePtr
		mainThread: WinApi.HANDLE
		
		told, shift: integer // used in Time()
		
		loader: LoaderHook
		loadres: integer
		
		wouldFinalize: boolean
		
		watcher*: proc (event: integer) // for debugging
		
		currentCoroutine, mainCoroutine: Coroutine
		mainCoroutineRefcnt: integer
	
	
	// code procedures for exception handling
	
	proc PushFP end // [code] 055H
	proc PopFP end // [code] 05DH
	proc PushBX end // [code] 053H
	proc PopBX end // [code] 05BH
	proc PushSI end // [code] 056H
	proc PopSI end // [code] 05EH
	proc PushDI end // [code] 057H
	proc PopDI end // [code] 05FH
	proc LdSP8 end // [code] 08DH 065H 0F8H
	proc Return0(ret: integer)  end // [code] 0C3H
	proc ReturnCX(ret: integer)  end // [code] 05AH 001H 0CCH 0FFH 0E2H
	// POP DX; ADD SP,CX; JP DX
	proc FPageWord(offs: integer): integer  end // [code] 64H 8BH 0H // MOV EAX,FS:[EAX]
	proc InstallExcp*(var e: ExcpFrame)  end // [code] 64H 8BH 0DH 0 0 0 0 89H 8 64H 0A3H 0 0 0 0
	proc RemoveExcp*(var e: ExcpFrame)  end // [code] 8BH 0 64H 0A3H 0 0 0 0
	
	// code procedures for fpu
	
	proc FINIT end // [code] 0DBH 0E3H
	proc FLDCW end // [code] 0D9H 06DH 0FCH // -4, FP
	proc FSTCW end // [code] 0D9H 07DH 0FCH // -4, FP
	
	// code procedure for memory erase
	
	proc Erase(adr, words: integer)  end // [code] 089H 0C7H 031H 0C0H 059H 0F2H 0ABH
	// MOV EDI, EAX
	// XOR EAX, EAX
	// POP ECX
	// REP STOS
	
	// code procedure for stack allocate
	
	proc ALLOC end // [code] 0H // argument in CX // Rochus: added 0h, otherwise empty
	(* PUSH	EAX
	   ADD	ECX,-5
	   JNS	L0
	   XOR	ECX,ECX
	   L0: AND	ECX,-4	(n-8+3)/4*4
	   MOV	EAX,ECX
	   AND	EAX,4095
	   SUB	ESP,EAX
	   MOV	EAX,ECX
	   SHR	EAX,12
	   JEQ	L2
	   L1: PUSH	0
	   SUB	ESP,4092
	   DEC	EAX
	   JNE	L1
	   L2: ADD	ECX,8
	   MOV	EAX,[ESP,ECX,-4]
	   PUSH	EAX
	   MOV	EAX,[ESP,ECX,-4]
	   SHR	ECX,2
	   RET *)
	
	
	
	// code procedures for COM support
	
	proc ADDREF end // [code] 08BH 04CH 024H 004H 0FFH 041H 004H 08BH 041H 008H 009H 0C0H 074H 00AH 050H 08BH 000H 0FFH 050H 004H 08BH 04CH 024H 004H 08BH 041H 004H 0C2H 004H 000H
	(* MOV	ECX,[ESP,4]
	   INC	[ECX,4]
	   MOV	EAX,[ECX,8]
	   OR	EAX,EAX
	   JE	L1
	   PUSH	EAX
	   MOV	EAX,[EAX]
	   CALL	[EAX,4]
	   MOV	ECX,[ESP,4]
	   L1: MOV	EAX,[ECX,4]
	   RET	4 *)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	proc RELEASE end // [code] 08BH 04CH 024H 004H 08BH 041H 008H 009H 0C0H 074H 00AH 050H 08BH 000H 0FFH 050H 008H 08BH 04CH 024H 004H 0FFH 049H 004H 08BH 041H 004H 0C2H 004H 000H
	(* MOV	ECX,[ESP,4]
	   MOV	EAX,[ECX,8]
	   OR	EAX,EAX
	   JE	L1
	   PUSH	EAX
	   MOV	EAX,[EAX]
	   CALL	[EAX,8]
	   MOV	ECX,[ESP,4]
	   L1: DEC	[ECX,4]
	   MOV	EAX,[ECX,4]
	   RET	4 *)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	proc CALLREL end // [code] 08BH 044H 024H 004H 083H 078H 004H 001H 075H 00BH 056H 057H 050H 08BH 040H 0FCH 0FFH 050H 0F8H 05FH 05EH
	(* MOV	EAX,[ESP,4]
	   CMP	[EAX,4],1
	   JNE	L1
	   PUSH	ESI
	   PUSH	EDI
	   PUSH	EAX
	   MOV	EAX,[EAX,-4]
	   CALL	[EAX,-8]
	   POP	EDI
	   POP	ESI
	   L1: *)
	
	
	
	
	
	
	
	
	
	
	
	
	
	proc (var id: Identifier) Identified*(): boolean  end // new abstract
	proc (r: Reducer) Reduce*(full: boolean)  end // new abstract
	proc (c: TrapCleaner) Cleanup* end // new empty
	
	
	// meta extension suport
	
	proc (e: ItemExt) Lookup*(name: array of wchar; var i: ANYREC)  end // new abstract
	proc (e: ItemExt) Index*(index: integer; var elem: ANYREC)  end // new abstract
	proc (e: ItemExt) Deref*(var ref: ANYREC)  end // new abstract
	
	proc (e: ItemExt) Valid*(): boolean  end // new abstract
	proc (e: ItemExt) Size*(): integer  end // new abstract
	proc (e: ItemExt) BaseTyp*(): integer  end // new abstract
	proc (e: ItemExt) Len*(): integer  end // new abstract
	
	proc (e: ItemExt) Call*(var ok: boolean)  end // new abstract
	proc (e: ItemExt) BoolVal*(): boolean  end // new abstract
	proc (e: ItemExt) PutBoolVal*(x: boolean)  end // new abstract
	proc (e: ItemExt) CharVal*(): wchar  end // new abstract
	proc (e: ItemExt) PutCharVal*(x: wchar)  end // new abstract
	proc (e: ItemExt) IntVal*(): integer  end // new abstract
	proc (e: ItemExt) PutIntVal*(x: integer)  end // new abstract
	proc (e: ItemExt) LongVal*(): longint  end // new abstract
	proc (e: ItemExt) PutLongVal*(x: longint)  end // new abstract
	proc (e: ItemExt) RealVal*(): longreal  end // new abstract
	proc (e: ItemExt) PutRealVal*(x: longreal)  end // new abstract
	proc (e: ItemExt) SetVal*(): set  end // new abstract
	proc (e: ItemExt) PutSetVal*(x: set)  end // new abstract
	proc (e: ItemExt) PtrVal*(): ANYPTR  end // new abstract
	proc (e: ItemExt) PutPtrVal*(x: ANYPTR)  end // new abstract
	proc (e: ItemExt) GetSStringVal*(var x: array of char
		var ok: boolean)  end // new abstract
	proc (e: ItemExt) PutSStringVal*(in x: array of char
		var ok: boolean)  end // new abstract
	proc (e: ItemExt) GetStringVal*(var x: array of wchar; var ok: boolean)  end // new abstract
	proc (e: ItemExt) PutStringVal*(in x: array of wchar; var ok: boolean)  end // new abstract
	
	
	// -------------------- miscellaneous tools --------------------
	
	proc IsAlpha*(ch: wchar): boolean 
		var 
			type_: shortint
			res: integer
	begin 
		// note that WinApi.IsCharAlphaW returns FALSE for all Hiragana and Katakana syllables and is slower
		res := WinApi.GetStringTypeW(WinApi.CT_CTYPE1, S.VAL(WinApi.PtrWSTR, S.ADR(ch)), 1, type_)
		return bits(WinApi.C1_ALPHA) * bits(type_) # {}
	end IsAlpha
	
	proc Upper*(ch: wchar): wchar 
	begin 
		if ("a" <= ch) & (ch <= "z") then // common case optimized
			return cap(ch) 
		elsif ch > 7fx then 
			return S.VAL(wchar, WinApi.CharUpperW(S.VAL(WinApi.PtrWSTR, ord(ch)))) 
		else 
			return ch 
		end 
	end Upper
	
	proc IsUpper*(ch: wchar): boolean 
	begin 
		if ("A" <= ch) & (ch <= "Z") then
			return true 
		elsif ch > 7fx then 
			return WinApi.IsCharUpperW(ch) # 0 
		else 
			return false 
		end 
	end IsUpper
	
	proc Lower*(ch: wchar): wchar 
	begin 
		if ("A" <= ch) & (ch <= "Z") then
			return wchr(ord(ch) + 32) 
		elsif ch > 7fx then 
			return S.VAL(wchar, WinApi.CharLowerW(S.VAL(WinApi.PtrWSTR, ord(ch)))) 
		else 
			return ch 
		end 
	end Lower
	
	proc IsLower*(ch: wchar): boolean 
	begin 
		if ("a" <= ch) & (ch <= "z") then
			return true 
		elsif ch > 7fx then 
			return WinApi.IsCharLowerW(ch) # 0 
		else 
			return false 
		end 
	end IsLower
	
	proc Utf8ToString*(in in_: array of char; var out: array of wchar
		var res: integer) 
		var 
			i, j, val_, max_: integer
			ch: char
		
		proc FormatError() 
		begin  // format error
			out := in_
			res := 2
		end FormatError
	
	begin 
		ch := in_[0]
		i := 1
		j := 0
		max_ := len(out) - 1
		while (ch # 0x) & (j < max_) do 
			if ch < 80x then
				out[j] := ch
				inc(j) 
			elsif ch < 0e0x then 
				val_ := ord(ch) - 192
				if val_ < 0 then
					FormatError
					return  
				end 
				ch := in_[i]
				inc(i)
				val_ := val_ * 64 + ord(ch) - 128
				if (ch < 80x) or (ch >= 0e0x) then
					FormatError
					return  
				end 
				out[j] := wchr(val_)
				inc(j) 
			elsif ch < 0f0x then 
				val_ := ord(ch) - 224
				ch := in_[i]
				inc(i)
				val_ := val_ * 64 + ord(ch) - 128
				if (ch < 80x) or (ch >= 0e0x) then
					FormatError
					return  
				end 
				ch := in_[i]
				inc(i)
				val_ := val_ * 64 + ord(ch) - 128
				if (ch < 80x) or (ch >= 0e0x) then
					FormatError
					return  
				end 
				out[j] := wchr(val_)
				inc(j) 
			else 
				FormatError
				return  
			end 
			ch := in_[i]
			inc(i) 
		end 
		out[j] := 0x
		if ch = 0x then // ok // truncated
			res := 0 
		else 
			res := 1 
		end 
	end Utf8ToString
	
	proc StringToUtf8*(in in_: array of wchar; var out: array of char
		var res: integer) 
		var 
			i, j, val_, max_: integer
	begin 
		i := 0
		j := 0
		max_ := len(out) - 3
		while (in_[i] # 0x) & (j < max_) do 
			val_ := ord(in_[i])
			inc(i)
			if val_ < 128 then
				out[j] := chr(val_)
				inc(j) 
			elsif val_ < 2048 then 
				out[j] := chr(val_ div 64 + 192)
				inc(j)
				out[j] := chr(val_ mod 64 + 128)
				inc(j) 
			else 
				out[j] := chr(val_ div 4096 + 224)
				inc(j)
				out[j] := chr(val_ div 64 mod 64 + 128)
				inc(j)
				out[j] := chr(val_ mod 64 + 128)
				inc(j) 
			end  
		end 
		out[j] := 0x
		if in_[i] = 0x then // ok // truncated
			res := 0 
		else 
			res := 1 
		end 
	end StringToUtf8
	
	proc SplitName*(name: array of wchar; var head, tail: array of wchar) 
		// portable
		var 
			i, j: integer
			ch, lch: wchar
	begin 
		i := 0
		ch := name[0]
		if ch # 0x then
			repeat 
				head[i] := ch
				lch := ch
				inc(i)
				ch := name[i] 
			until (ch = 0x) or (ch = ".") or IsUpper(ch) & ~IsUpper(lch) 
			if ch = "." then
				i := 0
				ch := name[0] 
			end 
			head[i] := 0x
			j := 0
			while ch # 0x do 
				tail[j] := ch
				inc(i)
				inc(j)
				ch := name[i] 
			end 
			tail[j] := 0x
			if tail = "" then
				tail := head
				head := "" 
			end  
		else 
			head := ""
			tail := "" 
		end 
	end SplitName
	
	proc MakeFileName*(var name: array of wchar; type_: array of wchar) 
		var 
			i, j: integer
			ext: array 8 of wchar
			ch: wchar
	begin 
		i := 0
		while (name[i] # 0x) & (name[i] # ".") do 
			inc(i) 
		end 
		if name[i] = "." then
			if name[i + 1] = 0x then
				name[i] := 0x 
			end  
		else 
			if type_ = "" then
				ext := docType 
			else 
				ext := type_ 
			end 
			if i < len(name) - len(ext) - 1 then
				name[i] := "."
				inc(i)
				j := 0
				ch := ext[0]
				while ch # 0x do 
					name[i] := Lower(ch)
					inc(i)
					inc(j)
					ch := ext[j] 
				end 
				name[i] := 0x 
			end  
		end 
	end MakeFileName
	
	proc Time*(): longint 
		var 
			t: integer
	begin 
		t := WinApi.GetTickCount()
		if t < told then
			inc(shift) 
		end 
		told := t
		return shift * 100000000h + t
	end Time
	
	proc Beep*() 
		var 
			res: integer
	begin 
		res := WinApi.MessageBeep(bits(-1))
	end Beep
	
	proc SearchProcVar*(var_: integer; var m: Module; var adr: integer) 
	begin 
		adr := var_
		m := nil
		if var_ # 0 then
			m := modList
			while (m # nil) & ((var_ < m.code) or (var_ >= m.code + m.csize)) do 
				m := m.next 
			end 
			if m # nil then
				dec(adr, m.code) 
			end  
		end 
	end SearchProcVar
	
	
	// -------------------- system memory management ---------------------
	
	proc GrowHeapMem(size_: integer; var c: Cluster) 
		// grow to at least size bytes, typically at least 256 kbytes are allocated
		const 
			N = 262144
		var 
			adr, s: integer
	begin 
		assert(size_ >= c.size_, 100)
		if size_ <= c.max_ then
			s := (size_ + (N - 1)) div N * N
			adr := WinApi.VirtualAlloc(S.VAL(integer, c), s, {12}, {6}) // commit; exec, read, write
			if adr # 0 then
				inc(used, s - c.size_)
				inc(total, s - c.size_)
				c.size_ := s 
			end  
		end 
	// post: (c.size unchanged) OR (c.size >= size)
	end GrowHeapMem
	
	proc AllocHeapMem(size_: integer; var c: Cluster) 
		// allocate at least size bytes, typically at least 256 kbytes are allocated
		const  // 1.5 GByte, see note on Stack Size
			M = 1536 * 100000h
		const  // cluster size for dll
			N = 65536
		var 
			adr, s: integer
	begin 
		if dllMem then
			inc(size_, 16)
			assert(size_ > 0, 100)
			adr := 0
			if size_ < N then
				adr := WinApi.HeapAlloc(heap, {0}, N) 
			end 
			if adr = 0 then
				adr := WinApi.HeapAlloc(heap, {0}, size_) 
			end 
			if adr = 0 then
				c := nil 
			else 
				c := S.VAL(Cluster, (adr + 15) div 16 * 16)
				c.max_ := adr
				c.size_ := WinApi.HeapSize(heap, {0}, adr) - (S.VAL(integer, c) - adr)
				inc(used, c.size_)
				inc(total, c.size_) 
			end  
		else 
			adr := 0
			s := M
			repeat 
				adr := WinApi.VirtualAlloc(01000000h, s, {13}, {6}) // reserve; exec, read, write
				if adr = 0 then
					adr := WinApi.VirtualAlloc(0, s, {13}, {6})  // reserve; exec, read, write
				end 
				s := s div 2 
			until adr # 0 
			if adr = 0 then
				c := nil 
			else 
				adr := WinApi.VirtualAlloc(adr, 1024, {12}, {6}) // commit; exec, read, write
				c := S.VAL(Cluster, adr)
				c.max_ := s * 2
				c.size_ := 0
				c.next := nil
				GrowHeapMem(size_, c)
				if c.size_ < size_ then
					c := nil 
				end  
			end  
		end 
	// post: (c = NIL) OR (c MOD 16 = 0) & (c.size >= size)
	end AllocHeapMem
	
	proc FreeHeapMem(c: Cluster) 
		var 
			res: integer
	begin 
		dec(used, c.size_)
		dec(total, c.size_)
		if dllMem then
			res := WinApi.HeapFree(heap, {0}, c.max_) 
		end 
	end FreeHeapMem
	
	proc HeapFull(size_: integer): boolean 
		var 
			ms: WinApi.MEMORYSTATUS
	begin 
		ms.dwLength := size(WinApi.MEMORYSTATUS)
		ms.dwMemoryLoad := -1
		WinApi.GlobalMemoryStatus(ms)
		return used + size_ > ms.dwTotalPhys
	end HeapFull
	
	proc AllocModMem*(descSize, modSize: integer; var descAdr, modAdr: integer) 
		var 
			res: integer
	begin 
		descAdr := WinApi.VirtualAlloc(0, descSize, {12, 13}, {6}) // reserve & commit; exec, read, write
		if descAdr # 0 then
			modAdr := WinApi.VirtualAlloc(0, modSize, {12, 13}, {6}) // reserve & commit; exec, read, write
			if modAdr # 0 then
				inc(used, descSize + modSize) 
			else 
				res := WinApi.VirtualFree(descAdr, 0, {15})
				descAdr := 0 
			end  
		else 
			modAdr := 0 
		end 
	end AllocModMem
	
	proc DeallocModMem*(descSize, modSize, descAdr, modAdr: integer) 
		var 
			res: integer
	begin 
		dec(used, descSize + modSize)
		res := WinApi.VirtualFree(descAdr, 0, {15}) // release
		res := WinApi.VirtualFree(modAdr, 0, {15}) // release
	end DeallocModMem
	
	proc InvalModMem(modSize, modAdr: integer) 
		var 
			res: integer
	begin 
		dec(used, modSize)
		res := WinApi.VirtualFree(modAdr, modSize, {14}) // decommit
	end InvalModMem
	
	proc IsReadable*(from, to_: integer): boolean 
	// check wether memory between from (incl.) and to (excl.) may be read
	begin 
		return WinApi.IsBadReadPtr(from, to_ - from) = 0
	end IsReadable
	
	
	// --------------------- COM reference counting --------------------
	
	proc AddRef*(p: integer): integer  // COMPILER DEPENDENT
	begin 
		ADDREF
	(* INC(p.ref);
	   IF p.unk # NIL THEN p.unk.AddRef() END;
	   RETURN p.ref *)
	
	
	end AddRef
	
	proc Release*(p: integer): integer  // COMPILER DEPENDENT
	begin 
		RELEASE
	(* IF p.unk # NIL THEN p.unk.Release() END;
	   DEC(p.ref);
	   RETURN p.ref *)
	
	
	end Release
	
	proc Release2*(p: integer): integer  // COMPILER DEPENDENT
	begin 
		CALLREL
		RELEASE
	(* IF p.ref = 1 THEN p.RELEASE END;
	   IF p.unk # NIL THEN p.unk.Release() END;
	   DEC(p.ref);
	   RETURN p.ref *)
	
	
	end Release2
	
	proc RecFinalizer(obj: ANYPTR) 
		var 
			i: integer
			type_: Type
			p: IntPtr
	begin 
		S.GET(S.VAL(integer, obj) - 4, type_)
		i := 0
		while type_.ptroffs[i] >= 0 do 
			inc(i) 
		end 
		inc(i)
		while type_.ptroffs[i] >= 0 do 
			p := S.VAL(IntPtr, S.VAL(integer, obj) + type_.ptroffs[i])
			inc(i)
			p.p := nil  // calls p.p.Release
		end 
	end RecFinalizer
	
	proc ArrFinalizer(obj: S.PTR) 
		var 
			last, adr, i, j: integer
			type_: Type
			p: IntPtr
	begin 
		S.GET(S.VAL(integer, obj) - 4, type_)
		type_ := S.VAL(Type, S.VAL(integer, type_) - 2) // remove array flag
		S.GET(S.VAL(integer, obj), last)
		S.GET(S.VAL(integer, obj) + 8, adr)
		j := 0
		while type_.ptroffs[j] >= 0 do 
			inc(j) 
		end 
		inc(j)
		while adr <= last do 
			i := j
			while type_.ptroffs[i] >= 0 do 
				p := S.VAL(IntPtr, adr + type_.ptroffs[i])
				inc(i)
				p.p := nil  // calls p.p.Release
			end 
			inc(adr, type_.size_) 
		end 
	end ArrFinalizer
	
	proc ReleaseIPtrs(mod_: Module) 
		var 
			i: integer
			p: IntPtr
	begin 
		if iptrs in mod_.opts then
			excl(mod_.opts, iptrs)
			i := mod_.nofptrs
			while mod_.ptrs[i] # -1 do 
				p := S.VAL(IntPtr, mod_.varBase + mod_.ptrs[i])
				inc(i)
				p.p := nil  // calls p.p.Release
			end  
		end 
	end ReleaseIPtrs
	
	
	// --------------------- NEW implementation (portable) --------------------
	
	proc NewRec*(typ: integer): integer  // implementation of NEW(ptr)
		var 
			size_: integer
			b: Block
			tag: Type
			l: FList
	begin 
		if odd(typ) then // record contains interface pointers
			tag := S.VAL(Type, typ - 1)
			b := NewBlock(tag.size_)
			if b = nil then
				return 0 
			end 
			b.tag := tag
			l := S.VAL(FList, S.ADR(b.last)) // anchor new object!
			l := S.VAL(FList, NewRec(S.TYP(FList))) // NEW(l)
			l.blk := b
			l.iptr := true
			l.next := finalizers
			finalizers := l
			return S.ADR(b.last) 
		else 
			tag := S.VAL(Type, typ)
			b := NewBlock(tag.size_)
			if b = nil then
				return 0 
			end 
			b.tag := tag
			S.GET(typ - 4, size_)
			if size_ # 0 then // record uses a finalizer
				l := S.VAL(FList, S.ADR(b.last)) // anchor new object!
				l := S.VAL(FList, NewRec(S.TYP(FList))) // NEW(l)
				l.blk := b
				l.next := finalizers
				finalizers := l 
			end 
			return S.ADR(b.last) 
		end 
	end NewRec
	
	proc NewArr*(eltyp, nofelem, nofdim: integer): integer  // impl. of NEW(ptr, dim0, dim1, ...)
		var 
			b: Block
			size_, headSize: integer
			t: Type
			fin: boolean
			l: FList
	begin 
		if (nofdim < 0) or (nofdim > (max(integer) - 12) div 4) then
			return 0 
		end 
		headSize := 4 * nofdim + 12
		fin := false
		case eltyp of 
			| -1: 
				eltyp := S.ADR(IntPtrType)
				fin := true 
			| 0: 
				eltyp := S.ADR(PtrType) 
			| 1: 
				eltyp := S.ADR(Char8Type) 
			| 2: 
				eltyp := S.ADR(Int16Type) 
			| 3: 
				eltyp := S.ADR(Int8Type) 
			| 4: 
				eltyp := S.ADR(Int32Type) 
			| 5: 
				eltyp := S.ADR(BoolType) 
			| 6: 
				eltyp := S.ADR(SetType) 
			| 7: 
				eltyp := S.ADR(Real32Type) 
			| 8: 
				eltyp := S.ADR(Real64Type) 
			| 9: 
				eltyp := S.ADR(Char16Type) 
			| 10: 
				eltyp := S.ADR(Int64Type) 
			| 11: 
				eltyp := S.ADR(ProcType) 
			| 12: 
				eltyp := S.ADR(UPtrType) 
		else  // eltyp is desc
			if odd(eltyp) then
				dec(eltyp)
				fin := true 
			end  
		end 
		t := S.VAL(Type, eltyp)
		assert(t.size_ > 0, 100)
		if (nofelem < 0) or (nofelem > (max(integer) - headSize) div t.size_) then
			return 0 
		end 
		size_ := headSize + nofelem * t.size_
		b := NewBlock(size_)
		if b = nil then
			return 0 
		end 
		b.tag := S.VAL(Type, eltyp + 2) // tag + array mark
		b.last := S.ADR(b.last) + size_ - t.size_ // pointer to last elem
		b.first := S.ADR(b.last) + headSize // pointer to first elem
		if fin then
			l := S.VAL(FList, S.ADR(b.last)) // anchor new object!
			l := S.VAL(FList, NewRec(S.TYP(FList))) // NEW(l)
			l.blk := b
			l.aiptr := true
			l.next := finalizers
			finalizers := l 
		end 
		return S.ADR(b.last)
	end NewArr
	
	
	// -------------------- handler installation (portable) ---------------------
	
	proc ThisFinObj*(var id: Identifier): ANYPTR 
		var 
			l: FList
	begin 
		assert(id.typ # 0, 100)
		l := finalizers
		while l # nil do 
			if S.VAL(integer, l.blk.tag) = id.typ then
				id.obj := S.VAL(ANYPTR, S.ADR(l.blk.last))
				if id.Identified() then
					return id.obj 
				end  
			end 
			l := l.next 
		end 
		return nil
	end ThisFinObj
	
	proc InstallReducer*(r: Reducer) 
	begin 
		r.next := reducers
		reducers := r
	end InstallReducer
	
	proc InstallTrapViewer*(h: Handler) 
	begin 
		trapViewer := h
	end InstallTrapViewer
	
	proc InstallTrapChecker*(h: Handler) 
	begin 
		trapChecker := h
	end InstallTrapChecker
	
	proc PushTrapCleaner*(c: TrapCleaner) 
		var 
			t: TrapCleaner
	begin 
		t := trapStack
		while (t # nil) & (t # c) do 
			t := t.next 
		end 
		assert(t = nil, 20)
		c.next := trapStack
		trapStack := c
	end PushTrapCleaner
	
	proc PopTrapCleaner*(c: TrapCleaner) 
		var 
			t: TrapCleaner
	begin 
		t := nil
		while (trapStack # nil) & (t # c) do 
			t := trapStack
			trapStack := trapStack.next 
		end 
	end PopTrapCleaner
	
	proc InstallCleaner*(p: Command) 
		var 
			c: CList
	begin 
		c := S.VAL(CList, NewRec(S.TYP(CList))) // NEW(c)
		c.do_ := p
		c.trapped := false
		c.next := cleaners
		cleaners := c
	end InstallCleaner
	
	proc RemoveCleaner*(p: Command) 
		var 
			c0, c: CList
	begin 
		c := cleaners
		c0 := nil
		while (c # nil) & (c.do_ # p) do 
			c0 := c
			c := c.next 
		end 
		if c # nil then
			if c0 = nil then
				cleaners := cleaners.next 
			else 
				c0.next := c.next 
			end  
		end 
	end RemoveCleaner
	
	proc Cleanup*
		var 
			c, c0: CList
	begin 
		c := cleaners
		c0 := nil
		while c # nil do 
			if ~c.trapped then
				c.trapped := true
				c.do_
				c.trapped := false
				c0 := c 
			else 
				if c0 = nil then
					cleaners := cleaners.next 
				else 
					c0.next := c.next 
				end  
			end 
			c := c.next 
		end 
	end Cleanup
	
	// -------------------- meta information (portable) ---------------------
	
	proc (h: LoaderHook) ThisMod*(in name: array of wchar): Module  end // new abstract
	
	proc SetLoaderHook*(h: LoaderHook) 
	begin 
		loader := h
	end SetLoaderHook
	
	proc InitModule(mod_: Module)  // initialize linked modules
		var 
			body: Command
	begin 
		if ~(dyn in mod_.opts) & (mod_.next # nil) & ~(init in mod_.next.opts) then
			InitModule(mod_.next) 
		end 
		if ~(init in mod_.opts) then
			body := S.VAL(Command, mod_.code)
			incl(mod_.opts, init)
			actual := mod_
			body()
			actual := nil 
		end 
	end InitModule
	
	proc ThisLoadedMod*(in name: array of wchar): Module  // loaded modules only
		var 
			m: Module
			res: integer
			n: Utf8Name
	begin 
		StringToUtf8(name, n, res)
		assert(res = 0)
		loadres := done
		m := modList
		while (m # nil) & ((m.name # n) or (m.refcnt < 0)) do 
			m := m.next 
		end 
		if (m # nil) & ~(init in m.opts) then
			InitModule(m) 
		end 
		if m = nil then
			loadres := moduleNotFound 
		end 
		return m
	end ThisLoadedMod
	
	proc ThisMod*(in name: array of wchar): Module 
	begin 
		if loader # nil then
			loader.res := done
			return loader.ThisMod(name) 
		else 
			return ThisLoadedMod(name) 
		end 
	end ThisMod
	
	proc LoadMod*(in name: array of wchar) 
		var 
			m: Module
	begin 
		m := ThisMod(name)
	end LoadMod
	
	proc GetLoaderResult*(var res: integer; var importing, imported, object: array of wchar) 
	begin 
		if loader # nil then
			res := loader.res
			importing := loader.importing
			imported := loader.imported
			object := loader.object 
		else 
			res := loadres
			importing := ""
			imported := ""
			object := "" 
		end 
	end GetLoaderResult
	
	proc ThisObject*(mod_: Module; in name: array of wchar): Object 
		var 
			l, r, m, res: integer
			p: StrPtr
			n: Utf8Name
	begin 
		StringToUtf8(name, n, res)
		assert(res = 0)
		l := 0
		r := mod_.export.num
		while l < r do  // binary search
			m := (l + r) div 2
			p := S.VAL(StrPtr, S.ADR(mod_.names[mod_.export.obj[m].id div 256]))
			if p^ = n then
				return S.VAL(Object, S.ADR(mod_.export.obj[m])) 
			end 
			if p^ < n then
				l := m + 1 
			else 
				r := m 
			end  
		end 
		return nil
	end ThisObject
	
	proc ThisDesc*(mod_: Module; fprint: integer): Object 
		var 
			i, n: integer
	begin 
		i := 0
		n := mod_.export.num
		while (i < n) & (mod_.export.obj[i].id div 256 = 0) do 
			if mod_.export.obj[i].offs = fprint then
				return S.VAL(Object, S.ADR(mod_.export.obj[i])) 
			end 
			inc(i) 
		end 
		return nil
	end ThisDesc
	
	proc ThisField*(rec: Type; in name: array of wchar): Object 
		var 
			n, res: integer
			p: StrPtr
			obj: Object
			m: Module
			nn: Utf8Name
	begin 
		StringToUtf8(name, nn, res)
		assert(res = 0)
		m := rec.mod_
		obj := S.VAL(Object, S.ADR(rec.fields.obj[0]))
		n := rec.fields.num
		while n > 0 do 
			p := S.VAL(StrPtr, S.ADR(m.names[obj.id div 256]))
			if p^ = nn then
				return obj 
			end 
			dec(n)
			inc(S.VAL(integer, obj), 16) 
		end 
		return nil
	end ThisField
	
	proc ThisCommand*(mod_: Module; in name: array of wchar): Command 
		var 
			x: Object
			sig: Signature
	begin 
		x := ThisObject(mod_, name)
		if (x # nil) & (x.id mod 16 = mProc) then
			sig := S.VAL(Signature, x.struct)
			if (sig.retStruct = nil) & (sig.num = 0) then
				return S.VAL(Command, mod_.procBase + x.offs) 
			end  
		end 
		return nil
	end ThisCommand
	
	proc ThisType*(mod_: Module; in name: array of wchar): Type 
		var 
			x: Object
	begin 
		x := ThisObject(mod_, name)
		if (x # nil) & (x.id mod 16 = mTyp) & (S.VAL(integer, x.struct) div 256 # 0) then
			return x.struct 
		else 
			return nil 
		end 
	end ThisType
	
	proc TypeOf*(in rec: ANYREC): Type 
	begin 
		return S.VAL(Type, S.TYP(rec))
	end TypeOf
	
	proc LevelOf*(t: Type): shortint 
	begin 
		return short(t.id div 16 mod 16)
	end LevelOf
	
	proc NewObj*(var o: S.PTR; t: Type) 
		var 
			i: integer
	begin 
		if t.size_ = -1 then
			o := nil 
		else 
			i := 0
			while t.ptroffs[i] >= 0 do 
				inc(i) 
			end 
			if t.ptroffs[i + 1] >= 0 then // with interface pointers
				inc(S.VAL(integer, t)) 
			end 
			o := S.VAL(S.PTR, NewRec(S.VAL(integer, t)))  // generic NEW
		end 
	end NewObj
	
	proc GetModName*(mod_: Module; var name: Name) 
		var 
			res: integer
	begin 
		Utf8ToString(mod_.name, name, res)
		assert(res = 0)
	end GetModName
	
	proc GetObjName*(mod_: Module; obj: Object; var name: Name) 
		var 
			p: StrPtr
			res: integer
	begin 
		p := S.VAL(StrPtr, S.ADR(mod_.names[obj.id div 256]))
		Utf8ToString(p^, name, res)
		assert(res = 0)
	end GetObjName
	
	proc GetTypeName*(t: Type; var name: Name) 
		var 
			p: StrPtr
			res: integer
	begin 
		p := S.VAL(StrPtr, S.ADR(t.mod_.names[t.id div 256]))
		Utf8ToString(p^, name, res)
		assert(res = 0)
	end GetTypeName
	
	proc RegisterMod*(mod_: Module) 
		var 
			i: integer
			t: WinApi.SYSTEMTIME
	begin 
		mod_.next := modList
		modList := mod_
		mod_.refcnt := 0
		incl(mod_.opts, dyn)
		i := 0
		while i < mod_.nofimps do 
			if mod_.imports[i] # nil then
				inc(mod_.imports[i].refcnt) 
			end 
			inc(i) 
		end 
		WinApi.GetLocalTime(t)
		mod_.loadTime[0] := t.wYear
		mod_.loadTime[1] := t.wMonth
		mod_.loadTime[2] := t.wDay
		mod_.loadTime[3] := t.wHour
		mod_.loadTime[4] := t.wMinute
		mod_.loadTime[5] := t.wSecond
		if ~(init in mod_.opts) then
			InitModule(mod_) 
		end 
	end RegisterMod
	
	proc UnloadMod*(mod_: Module) 
		var 
			i: integer
			t: Command
	begin 
		if mod_.refcnt = 0 then
			t := mod_.term
			mod_.term := nil
			if t # nil then // terminate module
				t()
				if mod_.refcnt # 0 then
					return  
				end  
			end 
			i := 0
			while i < mod_.nofptrs do  // release global pointers
				S.PUT(mod_.varBase + mod_.ptrs[i], 0)
				inc(i) 
			end 
			ReleaseIPtrs(mod_) // release global interface pointers
			Collect // call finalizers
			i := 0
			while i < mod_.nofimps do  // release imported modules
				if mod_.imports[i] # nil then
					dec(mod_.imports[i].refcnt) 
				end 
				inc(i) 
			end 
			mod_.refcnt := -1
			if dyn in mod_.opts then // release memory
				InvalModMem(mod_.data + mod_.dsize - mod_.refs, mod_.refs) 
			end  
		end 
	end UnloadMod
	
	// -------------------- dynamic procedure call ---------------------// COMPILER DEPENDENT
	
	proc PUSH(p: integer)  end // [code] 050H // push AX
	proc CALL(a: integer)  end // [code] 0FFH 0D0H // call AX
	proc RETI(): longint  end // [code] 0H // Rochus: add 0H
	proc RETR(): longreal  end // [code] 0H // Rochus: add 0H
	
	(* type				par
	   32 bit scalar	value
	   64 bit scalar	low hi
	   var scalar		address
	   record			address tag
	   array			address size
	   open array	address length_N-1 .. length_0 *)
	
	
	proc Call*(adr: integer; sig: Signature; in par: array of integer; n: integer): longint 
		var 
			p, kind, sp, size_: integer
			typ: Type
			r: longreal
	begin 
		p := sig.num
		while p > 0 do  // push parameters from right to left
			dec(p)
			typ := sig.par[p].struct
			kind := sig.par[p].id mod 16
			if (S.VAL(integer, typ) div 256 = 0) or (typ.id mod 4 in {0, 3}) then // scalar, ANYREC
				if (kind = 10) & ((S.VAL(integer, typ) = 8) or (S.VAL(integer, typ) = 10)) then // 64 bit
					dec(n) // push hi word
					PUSH(par[n]) 
				elsif S.VAL(integer, typ) = 11 then  // ANYREC
					assert(kind # 10) // not a value par, also checked by compiler
					dec(n) // push tag
					PUSH(par[n]) 
				end 
				dec(n) // push value/address
				PUSH(par[n]) 
			elsif typ.id mod 4 = 1 then  // record
				if kind # 10 then // var par
					dec(n) // push tag
					PUSH(par[n])
					dec(n) // push address
					PUSH(par[n]) 
				else 
					dec(n, 2) // skip tag
					S.GETREG(SP, sp) // allocate space
					sp := (sp - typ.size_) div 4 * 4
					S.PUTREG(SP, sp)
					S.MOVE(par[n], sp, typ.size_)  // copy to stack
				end  
			elsif typ.size_ = 0 then  // open array
				size_ := typ.id div 16 mod 16 // number of open dimensions
				while size_ > 0 do 
					dec(size_) // push length
					dec(n)
					PUSH(par[n]) 
				end 
				dec(n) // push address
				PUSH(par[n]) 
			else  // fix array
				if kind # 10 then // var par
					dec(n, 2) // push address
					PUSH(par[n]) 
				else 
					dec(n)
					size_ := par[n]
					dec(n)
					S.GETREG(SP, sp) // allocate space
					sp := (sp - size_) div 4 * 4
					S.PUTREG(SP, sp)
					S.MOVE(par[n], sp, size_)  // copy to stack
				end  
			end  
		end 
		assert(n = 0)
		if S.VAL(integer, sig.retStruct) = 7 then // shortreal
			CALL(adr)
			return S.VAL(integer, short(RETR()))  // return value in fpu register
		elsif S.VAL(integer, sig.retStruct) = 8 then  // real
			CALL(adr)
			r := RETR()
			return S.VAL(longint, r)  // return value in fpu register
		else 
			CALL(adr)
			return RETI()  // return value in integer registers
		end 
	end Call
	
	// -------------------- reference information (portable) ---------------------
	
	proc RefCh(var ref: integer; var ch: char) 
	begin 
		S.GET(ref, ch)
		inc(ref)
	end RefCh
	
	proc RefNum(var ref: integer; var x: integer) 
		var 
			s, n: integer
			ch: char
	begin 
		s := 0
		n := 0
		RefCh(ref, ch)
		while ord(ch) >= 128 do 
			inc(n, ash(ord(ch) - 128, s))
			inc(s, 7)
			RefCh(ref, ch) 
		end 
		x := n + ash(ord(ch) mod 64 - ord(ch) div 64 * 64, s)
	end RefNum
	
	proc RefName(var ref: integer; var n: Utf8Name) 
		var 
			i: integer
			ch: char
	begin 
		i := 0
		RefCh(ref, ch)
		while ch # 0x do 
			n[i] := ch
			inc(i)
			RefCh(ref, ch) 
		end 
		n[i] := 0x
	end RefName
	
	proc GetRefProc*(var ref: integer; var adr: integer; var name: Utf8Name) 
		var 
			ch: char
	begin 
		S.GET(ref, ch)
		while ch >= 0fdx do  // skip variables
			inc(ref)
			RefCh(ref, ch)
			if ch = 10x then
				inc(ref, 4) 
			end 
			RefNum(ref, adr)
			RefName(ref, name)
			S.GET(ref, ch) 
		end 
		while (ch > 0x) & (ch < 0fcx) do  // skip source refs
			inc(ref)
			RefNum(ref, adr)
			S.GET(ref, ch) 
		end 
		if ch = 0fcx then
			inc(ref)
			RefNum(ref, adr)
			RefName(ref, name) 
		else 
			adr := 0 
		end 
	end GetRefProc
	
	proc GetRefVar*(var ref: integer; var mode, form: char; var desc: Type
		var adr: integer; var name: Utf8Name) 
	begin 
		S.GET(ref, mode)
		desc := nil
		if mode >= 0fdx then
			mode := chr(ord(mode) - 0fch)
			inc(ref)
			RefCh(ref, form)
			if form = 10x then
				S.GET(ref, desc)
				inc(ref, 4)
				form := chr(16 + desc.id mod 4)
			end 
			RefNum(ref, adr)
			RefName(ref, name) 
		else 
			mode := 0x
			form := 0x
			adr := 0 
		end 
	end GetRefVar
	
	proc SourcePos*(mod_: Module; codePos: integer): integer 
		var 
			ref, pos, ad, d: integer
			ch: char
			name: Utf8Name
	begin 
		if mod_ # nil then // mf, 12.02.04
			ref := mod_.refs
			pos := 0
			ad := 0
			S.GET(ref, ch)
			while ch # 0x do 
				while (ch > 0x) & (ch < 0fcx) do  // srcref: {dAdr,dPos}
					inc(ad, ord(ch))
					inc(ref)
					RefNum(ref, d)
					if ad > codePos then
						return pos 
					end 
					inc(pos, d)
					S.GET(ref, ch) 
				end 
				if ch = 0fcx then // proc: 0FCX,Adr,Name
					inc(ref)
					RefNum(ref, d)
					RefName(ref, name)
					S.GET(ref, ch)
					if (d > codePos) & (pos > 0) then
						return pos 
					end  
				end 
				while ch >= 0fdx do  // skip variables: Mode, Form, adr, Name
					inc(ref)
					RefCh(ref, ch)
					if ch = 10x then
						inc(ref, 4) 
					end 
					RefNum(ref, d)
					RefName(ref, name)
					S.GET(ref, ch) 
				end  
			end  
		end 
		return -1
	end SourcePos
	
	// -------------------- dynamic link libraries ---------------------
	
	proc LoadDll*(in name: array of wchar; var ok: boolean) 
		var 
			h: WinApi.HANDLE
	begin 
		ok := false
		h := WinApi.LoadLibraryW(name)
		if h # 0 then
			ok := true 
		end 
	end LoadDll
	
	proc ThisDllObj*(mode, fprint: integer; in dll, name: array of wchar): integer 
		var 
			ad: WinApi.FARPROC
			h: WinApi.HANDLE
			res: integer
			sname: Utf8Name
	begin 
		ad := nil
		if mode = mProc then
			h := WinApi.GetModuleHandleW(dll)
			if h # 0 then
				StringToUtf8(name, sname, res)
				assert(res = 0)
				ad := WinApi.GetProcAddress(h, sname) 
			end  
		end 
		return S.VAL(integer, ad)
	end ThisDllObj
	
	// -------------------- garbage collector (portable) ---------------------
	
	proc Mark(this: Block) 
		var 
			father, son: Block
			tag: Type
			flag, offset, actual: integer
	begin 
		if ~odd(S.VAL(integer, this.tag)) then
			father := nil
			loop 
				inc(S.VAL(integer, this.tag))
				flag := S.VAL(integer, this.tag) mod 4
				tag := S.VAL(Type, S.VAL(integer, this.tag) - flag)
				if flag >= 2 then
					actual := this.first
					this.actual := actual 
				else 
					actual := S.ADR(this.last) 
				end 
				loop 
					offset := tag.ptroffs[0]
					if offset < 0 then
						inc(S.VAL(integer, tag), offset + 4) // restore tag
						if (flag >= 2) & (actual < this.last) & (offset < -4) then // next array element
							inc(actual, tag.size_)
							this.actual := actual 
						else  // up
							this.tag := S.VAL(Type, S.VAL(integer, tag) + flag)
							if father = nil then
								return  
							end 
							son := this
							this := father
							flag := S.VAL(integer, this.tag) mod 4
							tag := S.VAL(Type, S.VAL(integer, this.tag) - flag)
							offset := tag.ptroffs[0]
							if flag >= 2 then
								actual := this.actual 
							else 
								actual := S.ADR(this.last) 
							end 
							S.GET(actual + offset, father)
							S.PUT(actual + offset, S.ADR(son.last))
							inc(S.VAL(integer, tag), 4) 
						end  
					else 
						S.GET(actual + offset, son)
						if son # nil then
							dec(S.VAL(integer, son), 4)
							if ~odd(S.VAL(integer, son.tag)) then // down
								this.tag := S.VAL(Type, S.VAL(integer, tag) + flag)
								S.PUT(actual + offset, father)
								father := this
								this := son
								exit 
							end  
						end 
						inc(S.VAL(integer, tag), 4) 
					end  
				end  
			end  
		end 
	end Mark
	
	proc MarkGlobals
		var 
			m: Module
			i, p: integer
	begin 
		m := modList
		while m # nil do 
			if m.refcnt >= 0 then
				i := 0
				while i < m.nofptrs do 
					S.GET(m.varBase + m.ptrs[i], p)
					inc(i)
					if p # 0 then
						Mark(S.VAL(Block, p - 4)) 
					end  
				end  
			end 
			m := m.next 
		end 
	end MarkGlobals
	
	(* This is the specification for the code procedure following below:
	   
	   PROCEDURE Next (b: Block): Block;	(* next block in same cluster *)
	   VAR size: INTEGER;
	   BEGIN
	   S.GET(S.VAL(INTEGER, b.tag) DIV 4 * 4, size);
	   IF ODD(S.VAL(INTEGER, b.tag) DIV 2) THEN INC(size, b.last - S.ADR(b.last)) END;
	   RETURN S.VAL(Block, S.VAL(INTEGER, b) + (size + 19) DIV 16 * 16)
	   END Next; *)
	
	
	proc Next(b: Block): Block  end // [code] 08BH 008H 080H 0E1H 0FCH 08BH 009H 0F6H 000H 002H 074H 008H 003H 048H 004H 029H 0C1H 083H 0E9H 004H 083H 0C1H 013H 080H 0E1H 0F0H 001H 0C8H // next block in same cluster
	(* MOV	ECX,[EAX]	b.tag
	   AND	CL,0FCH	b.tag DIV * 4
	   MOV	ECX,[ECX]	size
	   TESTB	[EAX],02H	ODD(b.tag DIV 2)
	   JE	L1
	   ADD	ECX,[EAX,4]	size + b.last
	   SUB	ECX,EAX
	   SUB	ECX,4	size + b.last - ADR(b.last)
	   L1:
	   ADD	ECX,19	size + 19
	   AND	CL,0F0H	(size + 19) DIV 16 * 16
	   ADD	EAX,ECX	b + size *)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	proc CheckCandidates
		// pre: nofcand > 0
		var 
			i, j, h, p, end_: integer
			c: Cluster
			blk, next: Block
	begin 
		// sort candidates (shellsort)
		h := 1
		repeat 
			h := h * 3 + 1 
		until h > nofcand 
		repeat 
			h := h div 3
			i := h
			while i < nofcand do 
				p := candidates[i]
				j := i
				while (j >= h) & (candidates[j - h] > p) do 
					candidates[j] := candidates[j - h]
					j := j - h 
				end 
				candidates[j] := p
				inc(i) 
			end  
		until h = 1 
		// sweep
		c := root
		i := 0
		while c # nil do 
			blk := S.VAL(Block, S.VAL(integer, c) + 12)
			end_ := S.VAL(integer, blk) + (c.size_ - 12) div 16 * 16
			while candidates[i] < S.VAL(integer, blk) do 
				inc(i)
				if i = nofcand then
					return  
				end  
			end 
			while S.VAL(integer, blk) < end_ do 
				next := Next(blk)
				if candidates[i] < S.VAL(integer, next) then
					if (S.VAL(integer, blk.tag) # S.ADR(blk.last))  // not a free block
						& (~strictStackSweep or (candidates[i] = S.ADR(blk.last))) then
						Mark(blk) 
					end 
					repeat 
						inc(i)
						if i = nofcand then
							return  
						end  
					until candidates[i] >= S.VAL(integer, next)  
				end 
				if (S.VAL(integer, blk.tag) mod 4 = 0) & (S.VAL(integer, blk.tag) # S.ADR(blk.last)) 
					& (blk.tag.base[0] = nil) & (blk.actual > 0) then // referenced interface record
					Mark(blk) 
				end 
				blk := next 
			end 
			c := c.next 
		end 
	end CheckCandidates
	
	(* coroutine stacks are only checked if they are anchored in globals. If all coroutine stacks were checked,
	   unreferenced coroutines would survive forever because the stack contains a reference to the coroutine.
	   mainCoroutine and currentCoroutine are always anchored globally. *)
	proc MarkReferencedCoroutines(min_, max_: integer) 
		var 
			c, stop: Coroutine
			sp, sb, tag, p: integer
	begin 
		candidates[0] := max_ // ensure complete scan for interface mark
		nofcand := 1
		c := mainCoroutine
		repeat 
			c.stackChecked := false
			c := c.next 
		until c = mainCoroutine 
		repeat 
			c := mainCoroutine
			stop := c
			repeat  // tries to minimize the number of CheckCandidates calls
				sb := c.stackBase
				S.GET(S.VAL(integer, c) - size(ANYPTR), tag)
				if odd(tag) & (~c.stackChecked) & (sb # 0) then
					c.stackChecked := true
					sp := c.stackTop
					while sp < sb do 
						S.GET(sp, p)
						if (p > min_) & (p < max_) & (~strictStackSweep or (p mod 16 = 0)) then
							candidates[nofcand] := p
							inc(nofcand)
							if nofcand = len(candidates) - 1 then
								CheckCandidates
								nofcand := 0
								stop := c 
							end  
						end 
						inc(sp, 4) 
					end  
				end 
				c := c.next 
			until c = stop 
			if nofcand > 0 then
				CheckCandidates
				nofcand := 0
				c := nil 
			end  
		until c = mainCoroutine 
	end MarkReferencedCoroutines
	
	proc MarkLocals
		var 
			sp, p, min_, max_: integer
			c: Cluster
	begin 
		S.GETREG(FP, sp)
		nofcand := 0
		c := root
		while c.next # nil do 
			c := c.next 
		end 
		min_ := S.VAL(integer, root)
		max_ := S.VAL(integer, c) + c.size_
		if currentCoroutine = nil then // classical single stack
			while sp < baseStack do 
				S.GET(sp, p)
				if (p > min_) & (p < max_) & (~strictStackSweep or (p mod 16 = 0)) then
					candidates[nofcand] := p
					inc(nofcand)
					if nofcand = len(candidates) - 1 then
						CheckCandidates
						nofcand := 0 
					end  
				end 
				inc(sp, 4) 
			end 
			candidates[nofcand] := max_ // ensure complete scan for interface mark
			inc(nofcand)
			if nofcand > 0 then
				CheckCandidates 
			end  
		else  // with coroutine support
			currentCoroutine.stackTop := sp
			MarkReferencedCoroutines(min_, max_) 
		end 
	end MarkLocals
	
	proc MarkFinObj
		var 
			f: FList
	begin 
		wouldFinalize := false
		f := finalizers
		while f # nil do 
			if ~odd(S.VAL(integer, f.blk.tag)) then
				wouldFinalize := true 
			end 
			Mark(f.blk)
			f := f.next 
		end 
		f := hotFinalizers
		while f # nil do 
			if ~odd(S.VAL(integer, f.blk.tag)) then
				wouldFinalize := true 
			end 
			Mark(f.blk)
			f := f.next 
		end 
	end MarkFinObj
	
	proc CheckFinalizers
		var 
			f, g, h, k: FList
	begin 
		f := finalizers
		g := nil
		if hotFinalizers = nil then
			k := nil 
		else 
			k := hotFinalizers
			while k.next # nil do 
				k := k.next 
			end  
		end 
		while f # nil do 
			h := f
			f := f.next
			if ~odd(S.VAL(integer, h.blk.tag)) then
				if g = nil then
					finalizers := f 
				else 
					g.next := f 
				end 
				if k = nil then
					hotFinalizers := h 
				else 
					k.next := h 
				end 
				k := h
				h.next := nil 
			else 
				g := h 
			end  
		end 
		h := hotFinalizers
		while h # nil do 
			Mark(h.blk)
			h := h.next 
		end 
	end CheckFinalizers
	
	proc ExecFinalizer(a, b, c: integer) 
		var 
			f: FList
			fin: proc (this: ANYPTR)
	begin 
		f := S.VAL(FList, a)
		if f.aiptr then
			ArrFinalizer(S.VAL(ANYPTR, S.ADR(f.blk.last))) 
		else 
			S.GET(S.VAL(integer, f.blk.tag) - 4, fin) // method 0
			if (fin # nil) & (f.blk.tag.mod_.refcnt >= 0) then
				fin(S.VAL(ANYPTR, S.ADR(f.blk.last))) 
			end 
			if f.iptr then
				RecFinalizer(S.VAL(ANYPTR, S.ADR(f.blk.last))) 
			end  
		end 
	end ExecFinalizer // COMPILER DEPENDENT
	
	proc CallFinalizers
		var 
			f: FList
	begin 
		while hotFinalizers # nil do 
			f := hotFinalizers
			hotFinalizers := hotFinalizers.next
			Try(ExecFinalizer, S.VAL(integer, f), 0, 0) 
		end 
		wouldFinalize := false
	end CallFinalizers
	
	proc Insert(blk: FreeBlock; size_: integer)  // insert block in free list
		var 
			i: integer
	begin 
		blk.size_ := size_ - 4
		blk.tag := S.VAL(Type, S.ADR(blk.size_))
		i := min(N - 1, (blk.size_ div 16))
		blk.next := free[i]
		free[i] := blk
	end Insert
	
	proc Sweep(dealloc: boolean) 
		var 
			cluster, last, c: Cluster
			blk, next: Block
			fblk, b, t: FreeBlock
			end_, i: integer
	begin 
		cluster := root
		last := nil
		allocated := 0
		i := N
		repeat 
			dec(i)
			free[i] := sentinel 
		until i = 0 
		while cluster # nil do 
			blk := S.VAL(Block, S.VAL(integer, cluster) + 12)
			end_ := S.VAL(integer, blk) + (cluster.size_ - 12) div 16 * 16
			fblk := nil
			while S.VAL(integer, blk) < end_ do 
				next := Next(blk)
				if odd(S.VAL(integer, blk.tag)) then
					if fblk # nil then
						Insert(fblk, S.VAL(integer, blk) - S.VAL(integer, fblk))
						fblk := nil 
					end 
					dec(S.VAL(integer, blk.tag)) // unmark
					inc(allocated, S.VAL(integer, next) - S.VAL(integer, blk)) 
				elsif fblk = nil then 
					fblk := S.VAL(FreeBlock, blk) 
				end 
				blk := next 
			end 
			if dealloc & dllMem 
				& (S.VAL(integer, fblk) = S.VAL(integer, cluster) + 12) then // deallocate cluster
				c := cluster
				cluster := cluster.next
				if last = nil then
					root := cluster 
				else 
					last.next := cluster 
				end 
				FreeHeapMem(c) 
			else 
				if fblk # nil then
					Insert(fblk, end_ - S.VAL(integer, fblk)) 
				end 
				last := cluster
				cluster := cluster.next 
			end  
		end 
		// reverse free list
		i := N
		repeat 
			dec(i)
			b := free[i]
			fblk := sentinel
			while b # sentinel do 
				t := b
				b := t.next
				t.next := fblk
				fblk := t 
			end 
			free[i] := fblk 
		until i = 0 
	end Sweep
	
	proc Collect*
	begin 
		if root # nil then
			CallFinalizers // trap cleanup
			if debug & (watcher # nil) then
				watcher(1) 
			end 
			MarkGlobals
			MarkLocals
			CheckFinalizers
			Sweep(true)
			CallFinalizers 
		end 
	end Collect
	
	proc FastCollect*
	begin 
		if root # nil then
			if debug & (watcher # nil) then
				watcher(2) 
			end 
			MarkGlobals
			MarkLocals
			MarkFinObj
			Sweep(false) 
		end 
	end FastCollect
	
	proc WouldFinalize*(): boolean 
	begin 
		return wouldFinalize
	end WouldFinalize
	
	// --------------------- memory allocation (portable) --------------------
	
	proc OldBlock(size_: integer): FreeBlock  // size MOD 16 = 0
		var 
			b, l: FreeBlock
			s, i: integer
	begin 
		if debug & (watcher # nil) then
			watcher(3) 
		end 
		s := size_ - 4
		i := min(N - 1, s div 16)
		while (i # N - 1) & (free[i] = sentinel) do 
			inc(i) 
		end 
		b := free[i]
		l := nil
		while b.size_ < s do 
			l := b
			b := b.next 
		end 
		if b # sentinel then
			if l = nil then
				free[i] := b.next 
			else 
				l.next := b.next 
			end  
		else 
			b := nil 
		end 
		return b
	end OldBlock
	
	proc LastBlock(limit: integer): FreeBlock  // size MOD 16 = 0
		var 
			b, l: FreeBlock
			s, i: integer
	begin 
		s := limit - 4
		i := 0
		repeat 
			b := free[i]
			l := nil
			while (b # sentinel) & (S.VAL(integer, b) + b.size_ # s) do 
				l := b
				b := b.next 
			end 
			if b # sentinel then
				if l = nil then
					free[i] := b.next 
				else 
					l.next := b.next 
				end  
			else 
				b := nil 
			end 
			inc(i) 
		until (b # nil) or (i = N) 
		return b
	end LastBlock
	
	proc NewBlock(size_: integer): Block 
		var 
			tsize, a, s: integer
			b: FreeBlock
			new_, c: Cluster
			r: Reducer
	begin 
		assert(size_ >= 0, 20)
		if size_ > max(integer) - 19 then
			return nil 
		end 
		tsize := (size_ + 19) div 16 * 16
		b := OldBlock(tsize) // 1) search for free block
		if b = nil then
			if dllMem then
				FastCollect // 2) collect
				b := OldBlock(tsize)
				if b = nil then
					Collect // 2a) fully collect
					b := OldBlock(tsize) 
				end 
				if b = nil then
					AllocHeapMem(tsize + 12, new_) // 3) allocate new cluster
					if new_ # nil then
						if (root = nil) or (S.VAL(integer, new_) < S.VAL(integer, root)) then
							new_.next := root
							root := new_ 
						else 
							c := root
							while (c.next # nil) & (S.VAL(integer, new_) > S.VAL(integer, c.next)) do 
								c := c.next 
							end 
							new_.next := c.next
							c.next := new_ 
						end 
						b := S.VAL(FreeBlock, S.VAL(integer, new_) + 12)
						b.size_ := (new_.size_ - 12) div 16 * 16 - 4 
					else 
						return nil  // 4) give up
					end  
				end  
			else 
				FastCollect // 2) collect
				b := OldBlock(tsize)
				if b = nil then
					Collect // 2a) fully collect
					b := OldBlock(tsize) 
				end 
				if (b = nil) & HeapFull(tsize) & (reducers # nil) then // 3) little space => reduce once
					r := reducers
					reducers := nil
					while r # nil do 
						r.Reduce(false)
						r := r.next 
					end 
					Collect 
				end 
				if b = nil then
					if tsize <= max(integer) div 3 * 2 - allocated then
						s := (tsize + allocated) div 2 * 3 
					elsif tsize <= root.max_ - allocated then 
						s := root.max_ 
					else 
						return nil 
					end 
					a := 12 + (root.size_ - 12) div 16 * 16
					if s <= total then
						b := OldBlock(tsize)
						if b = nil then
							s := a + tsize 
						end  
					elsif s < a + tsize then 
						s := a + tsize 
					end 
					if (b = nil) & (total < s) then // 4) enlarge heap
						GrowHeapMem(s, root)
						if root.size_ >= s then
							b := LastBlock(S.VAL(integer, root) + a)
							if b # nil then
								b.size_ := (root.size_ - a + b.size_ + 4) div 16 * 16 - 4 
							else 
								b := S.VAL(FreeBlock, S.VAL(integer, root) + a)
								b.size_ := (root.size_ - a) div 16 * 16 - 4 
							end  
						elsif reducers # nil then  // 5) no space => fully reduce
							r := reducers
							reducers := nil
							while r # nil do 
								r.Reduce(true)
								r := r.next 
							end 
							Collect 
						end  
					end  
				end 
				if b = nil then
					b := OldBlock(tsize)
					if b = nil then // 6) give up
						return nil 
					end  
				end  
			end  
		end 
		// b # NIL
		a := b.size_ + 4 - tsize
		if a > 0 then
			Insert(S.VAL(FreeBlock, S.VAL(integer, b) + tsize), a) 
		end 
		if size_ > 0 then
			Erase(S.ADR(b.size_), (size_ + 3) div 4) 
		end 
		inc(allocated, tsize)
		return S.VAL(Block, b)
	end NewBlock
	
	proc Allocated*(): integer 
	begin 
		return allocated
	end Allocated
	
	proc Used*(): integer 
	begin 
		return used
	end Used
	
	proc Root*(): integer 
	begin 
		return S.VAL(integer, root)
	end Root
	
	
	// -------------------- Trap Handling ---------------------
	
	proc Start*(code: Command) 
	begin 
		restart := code
		S.GETREG(SP, baseStack) // save base stack
		code()
	end Start
	
	proc Quit*(exitCode: integer) 
		var 
			m: Module
			term: Command
			t: boolean
	begin 
		trapViewer := nil
		trapChecker := nil
		restart := nil
		t := terminating
		terminating := true
		m := modList
		while m # nil do  // call terminators
			if ~static or ~t then
				term := m.term
				m.term := nil
				if term # nil then
					term() 
				end  
			end 
			ReleaseIPtrs(m)
			m := m.next 
		end 
		CallFinalizers
		hotFinalizers := finalizers
		finalizers := nil
		CallFinalizers
		WinOle.OleUninitialize()
		if ~inDll then
			RemoveExcp(excpPtr^)
			WinApi.ExitProcess(exitCode)  // never returns
		end 
	end Quit
	
	proc FatalError*(id: integer; str: array of wchar) 
		var 
			res: integer
			title: array 16 of wchar
	begin 
		title := "Error xy"
		title[6] := wchr(id div 10 + ord("0"))
		title[7] := wchr(id mod 10 + ord("0"))
		res := WinApi.MessageBoxW(0, str, title, {})
		if res = 0 then // win2000/XP
			res := WinApi.LoadLibraryA("COMCTL32.dll")
			res := WinApi.MessageBoxW(0, str, title, {}) 
		end 
		WinOle.OleUninitialize()
		if ~inDll then
			RemoveExcp(excpPtr^) 
		end 
		WinApi.ExitProcess(1)
	// never returns
	end FatalError
	
	proc DefaultTrapViewer
		var 
			len_, ref, end_, x, a, b, c: integer
			mod_: Module
			modName, name: Name
			res: integer
			n: Utf8Name
			out: array 1024 of wchar
		
		proc WriteString(in s: array of wchar) 
			var 
				i: integer
		begin 
			i := 0
			while (len_ < len(out) - 1) & (s[i] # 0x) do 
				out[len_] := s[i]
				inc(i)
				inc(len_) 
			end 
		end WriteString
		
		proc WriteHex(x, n: integer) 
			var 
				i, y: integer
		begin 
			if len_ + n < len(out) then
				i := len_ + n - 1
				while i >= len_ do 
					y := x mod 16
					x := x div 16
					if y > 9 then
						y := y + (ord("A") - ord("0") - 10) 
					end 
					out[i] := wchr(y + ord("0"))
					dec(i) 
				end 
				inc(len_, n) 
			end 
		end WriteHex
		
		proc WriteLn
		begin 
			if len_ < len(out) - 1 then
				out[len_] := 0dx
				inc(len_) 
			end 
		end WriteLn
	
	begin 
		len_ := 0
		if err = 129 then
			WriteString("invalid with") 
		elsif err = 130 then 
			WriteString("invalid case") 
		elsif err = 131 then 
			WriteString("function without return") 
		elsif err = 132 then 
			WriteString("type guard") 
		elsif err = 133 then 
			WriteString("implied type guard") 
		elsif err = 134 then 
			WriteString("value out of range") 
		elsif err = 135 then 
			WriteString("index out of range") 
		elsif err = 136 then 
			WriteString("string too long") 
		elsif err = 137 then 
			WriteString("stack overflow") 
		elsif err = 138 then 
			WriteString("integer overflow") 
		elsif err = 139 then 
			WriteString("division by zero") 
		elsif err = 140 then 
			WriteString("infinite real result") 
		elsif err = 141 then 
			WriteString("real underflow") 
		elsif err = 142 then 
			WriteString("real overflow") 
		elsif err = 143 then 
			WriteString("undefined real result") 
		elsif err = 200 then 
			WriteString("keyboard interrupt") 
		elsif err = 202 then 
			WriteString("illegal instruction:  ")
			WriteHex(val_, 4) 
		elsif err = 203 then 
			WriteString("illegal memory read [ad = ")
			WriteHex(val_, 8)
			WriteString("]") 
		elsif err = 204 then 
			WriteString("illegal memory write [ad = ")
			WriteHex(val_, 8)
			WriteString("]") 
		elsif err = 205 then 
			WriteString("illegal execution [ad = ")
			WriteHex(val_, 8)
			WriteString("]") 
		elsif err < 0 then 
			WriteString("exception #")
			WriteHex(-err, 2) 
		else 
			err := err div 100 * 256 + err div 10 mod 10 * 16 + err mod 10
			WriteString("trap #")
			WriteHex(err, 3) 
		end 
		a := pc
		b := fp
		c := 12
		repeat 
			WriteLn
			WriteString("- ")
			mod_ := modList
			while (mod_ # nil) & ((a < mod_.code) or (a >= mod_.code + mod_.csize)) do 
				mod_ := mod_.next 
			end 
			if mod_ # nil then
				dec(a, mod_.code)
				if mod_.refcnt >= 0 then
					GetModName(mod_, modName)
					WriteString(modName)
					ref := mod_.refs
					repeat 
						GetRefProc(ref, end_, n) 
					until (end_ = 0) or (a < end_) 
					if a < end_ then
						Utf8ToString(n, name, res)
						WriteString(".")
						WriteString(name) 
					end  
				else 
					GetModName(mod_, modName)
					WriteString("(")
					WriteString(modName)
					WriteString(")") 
				end 
				WriteString("  ") 
			end 
			WriteString("(pc=")
			WriteHex(a, 8)
			WriteString(", fp=")
			WriteHex(b, 8)
			WriteString(")")
			if (b >= sp) & (b < stack) then
				S.GET(b + 4, a) // stacked pc
				S.GET(b, b) // dynamic link
				dec(c) 
			else 
				c := 0 
			end  
		until c = 0 
		out[len_] := 0x
		x := WinApi.MessageBoxW(0, out, "BlackBox", {})
		if x = 0 then // win2000/XP
			res := WinApi.LoadLibraryA("COMCTL32.dll")
			res := WinApi.MessageBoxW(0, out, "BlackBox", {}) 
		end 
	end DefaultTrapViewer
	
	proc TrapCleanup
		var 
			t: TrapCleaner
	begin 
		while trapStack # nil do 
			t := trapStack
			trapStack := trapStack.next
			t.Cleanup 
		end 
		if (trapChecker # nil) & (err # 128) then
			trapChecker 
		end 
	end TrapCleanup
	
	proc Unwind(f: ExcpFramePtr)  // COMPILER DEPENDENT
		const  // offset of Label: from proc start
			Label = 27
	begin 
		PushFP
		WinApi.RtlUnwind(S.VAL(WinApi.PtrVoid, f), S.ADR(Unwind) + Label, nil, 0)
		// Label:
		PopFP
	end Unwind
	
	// stack overflow is detected by means of a so-called 'page guard', which offers a one-shot protection
	proc ResetStackGuard
		var 
			stackLimit, regionSize: integer
			si: WinApi.SYSTEM_INFO
	begin 
		stackLimit := FPageWord(8) // cf. WinApi.NT_TIB.StackLimit
		WinApi.GetSystemInfo(si)
		regionSize := si.dwPageSize * 2 // 2 pages must be protected in order to catch all kinds of stack overflows
		res := WinApi.VirtualProtect(stackLimit, regionSize, WinApi.PAGE_READWRITE + WinApi.PAGE_GUARD, old)
		if res = 0 then
			res := WinApi.VirtualProtect(stackLimit, regionSize, WinApi.PAGE_NOACCESS, old) 
		end 
	end ResetStackGuard
	
	proc TrapHandler(excpRec: WinApi.PtrEXCEPTION_RECORD; estFrame: ExcpFramePtr
		context: WinApi.PtrCONTEXT; dispCont: integer): integer 
	// same parameter size as Try
	begin 
		if excpRec^.ExceptionFlags * {1, 2} = {} then
			if (excpRec.ExceptionCode mod 256 = 4) & ~interrupted then // wrong trace trap
				context.Dr7 := 0 // disable all debug traps
				LdSP8 // COMPILER DEPENDENT
				PopSI
				PopDI
				PopFP
				Return0(0)  // return continueExecution without parameter remove
			end 
			Unwind(estFrame)
			if trapped & (excpRec.ExceptionCode mod 256 # 1) & (excpRec.ExceptionCode mod 256 # 253) then
				DefaultTrapViewer
				if ~secondTrap then
					trapped := false
					secondTrap := true 
				end  
			end 
			err := -(excpRec.ExceptionCode mod 256)
			pc := context.Eip
			sp := context.Esp
			fp := context.Ebp
			if (currentCoroutine = nil) or (currentCoroutine.stackBase = baseStack) then
				stack := baseStack 
			else  // don't display a coroutine's TryHandler
				stack := currentCoroutine.stackBase - 3 * size(ANYPTR)  // COMPILER DEPENDENT
			end 
			if err = -4 then // keyboard interrupt
				err := 200 
			elsif err = -5 then 
				val_ := excpRec.ExceptionInformation[1]
				if val_ = pc then // call to undef adr
					err := 205
					S.GET(sp, pc)
					inc(sp, 4)
					dec(pc) 
				elsif excpRec.ExceptionInformation[0] = 0 then  // illegal read
					err := 203 
				else  // illegal write
					err := 204 
				end  
			elsif (err = -29) or (err = -30) then  // illegal instruction
				err := 202
				val_ := 0
				if IsReadable(excpRec.ExceptionAddress, excpRec.ExceptionAddress + 4) then
					S.GET(excpRec.ExceptionAddress, val_)
					if val_ mod 100h = 8dh then // lea reg,reg
						if val_ div 100h mod 100h = 0f0h then // trap
							err := val_ div 10000h mod 100h 
						elsif val_ div 1000h mod 10h = 0eh then 
							err := 128 + val_ div 100h mod 10h  // run time error
						end  
					end  
				end  
			elsif err = -142 then  // fpu: div by zero
				dec(pc)
				err := 140 
			elsif (err = -144) or (err = -146) then  // fpu: invalid op
				dec(pc)
				err := 143
				val_ := context.FloatSave.ControlWord mod 4096 * 65536 + context.FloatSave.StatusWord mod 65536 
			elsif err = -145 then  // fpu: overflow
				dec(pc)
				err := 142 
			elsif err = -147 then  // fpu: underflow
				dec(pc)
				err := 141 
			elsif err = -148 then  // division by zero
				err := 139 
			elsif err = -149 then  // integer overflow
				err := 138 
			elsif (err = -1) or (err = -253) then  // stack overflow
				err := 137 
			end 
			inc(trapCount)
			InitFpu
			if err # 137 then // stack overflow handling is delayed
				TrapCleanup
				if err = 128 then  // do nothing
				elsif (trapViewer # nil) & (restart # nil) & ~trapped & ~guarded then 
					trapped := true
					trapViewer() 
				else 
					DefaultTrapViewer 
				end  
			end 
			trapped := false
			secondTrap := false
			if dispCont = 0 then // InterfaceTrapHandler // COMPILER DEPENDENT
				RemoveExcp(estFrame^)
				S.PUTREG(CX, estFrame(ComExcpFramePtr).par)
				S.PUTREG(SP, S.VAL(integer, estFrame) + 12)
				if err = 137 then // retrigger stack overflow
					TrapCleanup
					DefaultTrapViewer
					ResetStackGuard 
				end 
				PopSI
				PopDI
				PopBX
				PopFP
				ReturnCX(WinApi.E_UNEXPECTED) 
			elsif estFrame # excpPtr then  // Try failed // COMPILER DEPENDENT
				RemoveExcp(estFrame^)
				res := S.VAL(integer, estFrame)
				S.PUTREG(FP, res + (size(ExcpFrame) + 8)) // restore fp
				S.PUTREG(SP, res - 4) // restore stack
				if err = 137 then // retrigger stack overflow
					TrapCleanup
					DefaultTrapViewer
					ResetStackGuard 
				end 
				PopBX
				return 0  // return from Try
			elsif restart # nil then  // Start failed
				S.PUTREG(FP, baseStack) // restore fp
				S.PUTREG(SP, baseStack) // restore stack
				if err = 137 then // retrigger stack overflow
					TrapCleanup
					DefaultTrapViewer
					ResetStackGuard 
				end 
				restart()
				Quit(1) 
			else  // boot process failed
				Quit(1) 
			end  
		// never returns
		else 
			LdSP8 // COMPILER DEPENDENT
			PopSI
			PopDI
			PopFP
			Return0(1)  // return continueSearch without parameter remove
		end 
	end TrapHandler
	
	proc SetTrapGuard*(on: boolean) 
	begin 
		guarded := on
	end SetTrapGuard
	
	proc Try*(h: TryHandler; a, b, c: integer)  // COMPILER DEPENDENT
		// same parameter size as TrapHandler
		var  // no other local variables!
			excp: ExcpFrame
	begin 
		PushBX
		excp.handler := TrapHandler
		InstallExcp(excp)
		h(a, b, c)
		RemoveExcp(excp)
		PopBX
	end Try
	
	proc InterfaceTrapHandler*(excpRec, estFrame, context, 
		dispCont: integer): integer  // known to compiler
		var 
			res: integer
	begin 
		res := TrapHandler(S.VAL(WinApi.PtrEXCEPTION_RECORD, excpRec), 
			S.VAL(ExcpFramePtr, estFrame), 
			S.VAL(WinApi.PtrCONTEXT, context), 
			0)
		// LdSP8 removes parameters of TrapHandler
		LdSP8 // COMPILER DEPENDENT
		PopSI
		PopDI
		PopFP
		Return0(1) // return continueSearch without parameter remove
		if false then
			return 0 
		end 
	end InterfaceTrapHandler
	
	// -------------------- keyboard interrupt handling ---------------------
	
	proc KeyboardWatcher(main: integer): integer  // runs in a thread
		type 
			P = proc (w: integer): integer
		var 
			res, a: integer
			top, h: WinApi.HANDLE
			done: boolean
			context: WinApi.CONTEXT
			mod_: Module
			isHungAppWindow: P
	begin 
		done := false
		isHungAppWindow := nil
		h := WinApi.LoadLibraryA("user32.dll")
		if h # 0 then
			isHungAppWindow := S.VAL(P, WinApi.GetProcAddress(h, "IsHungAppWindow")) 
		end 
		loop 
			res := WinApi.GetAsyncKeyState(WinApi.VK_CANCEL)
			if res >= 0 then // key released
				done := false
				WinApi.Sleep(10) 
			elsif ~done then  // key pressed
				top := WinApi.GetForegroundWindow()
				if (mainWnd # top) & (isHungAppWindow # nil) 
					& (top # 0) & (isHungAppWindow(top) # 0) 
					& (mainWnd # 0) & (isHungAppWindow(mainWnd) # 0) then
					// main window replaced by ghost window
					// check if application window is topmost nonresponding window
					repeat 
						top := WinApi.GetWindow(top, WinApi.GW_HWNDNEXT) 
					until (top = 0) or (isHungAppWindow(top) # 0) & (WinApi.IsWindowVisible(top) # 0)  
				end 
				if mainWnd = top then
					res := WinApi.SuspendThread(main)
					context.ContextFlags := {0, 16}
					res := WinApi.GetThreadContext(main, context)
					mod_ := modList
					a := context.Eip
					while (mod_ # nil) & ((a < mod_.code) or (a >= mod_.code + mod_.csize)) do 
						mod_ := mod_.next 
					end 
					if (mod_ # nil) & (mod_.name = "Kernel") then
						mod_ := nil 
					end 
					if mod_ # nil then
						interrupted := true
						incl(S.VAL(set, context.EFlags), 8) // set trap flag
						res := WinApi.SetThreadContext(main, context)
						done := true 
					end 
					res := WinApi.ResumeThread(main)
					WinApi.Sleep(1)
					interrupted := false 
				end  
			end  
		end 
		return 0
	end KeyboardWatcher
	
	proc InstallKeyboardInt
		var 
			res, id: integer
			t, main: WinApi.HANDLE
	begin 
		res := WinApi.DuplicateHandle(WinApi.GetCurrentProcess(), WinApi.GetCurrentThread(), 
			WinApi.GetCurrentProcess(), main, {1, 3, 4, 16..19}, 0, {})
		t := WinApi.CreateThread(nil, 4096, KeyboardWatcher, main, {}, id)
	end InstallKeyboardInt
	
	// -------------------- coroutine support ---------------------
	
	proc BeginCoroutines*(var main: Coroutine) 
	begin 
		assert(main # nil, 20)
		if mainCoroutine = nil then
			main.stackBase := baseStack
			main.next := main
			main.prev := main
			main.fiber := WinApi.ConvertThreadToFiber(0)
			if main.fiber # 0 then
				currentCoroutine := main
				mainCoroutine := main
				mainCoroutineRefcnt := 1 
			else 
				main := nil 
			end  
		else 
			inc(mainCoroutineRefcnt)
			main := mainCoroutine 
		end 
	end BeginCoroutines
	
	proc EndCoroutines*
		var 
			res: integer
	begin 
		if mainCoroutineRefcnt > 0 then
			dec(mainCoroutineRefcnt)
			if mainCoroutineRefcnt = 0 then
				currentCoroutine := nil
				mainCoroutine := nil
				res := WinApi.ConvertFiberToThread() 
			end  
		end 
	end EndCoroutines
	
	proc AddCoroutine*(this: Coroutine; startProc: proc (par: integer); par: integer
		stackMin, stackMax: integer; var done: boolean) 
	begin 
		assert(this.fiber = 0, 20) // reuse of 'this'  without RemoveCoroutine
		this.stackBase := 0 // reset because of possible reuse of 'this'
		// Windows seems to use the default also for a very small stack size, so we better avoid it
		if (stackMin # 0) & (stackMin < 1000) then
			stackMin := 1000 
		end 
		if (stackMax # 0) & (stackMax < 2000) then
			stackMax := 2000 
		end 
		this.fiber := WinApi.CreateFiberEx(stackMin, stackMax, {}, startProc, par)
		if this.fiber # 0 then
			done := true
			this.next := currentCoroutine.next
			this.prev := currentCoroutine
			currentCoroutine.next.prev := this
			currentCoroutine.next := this 
		else  // swap space or virtual address space exhausted
			done := false 
		end 
	end AddCoroutine
	
	proc SetCoroutineBase*(this: Coroutine) 
	begin 
		assert(this.stackBase = 0)
		this.stackBase := S.ADR(this) + size(ANYPTR) // COMPILER DEPENDENT
	end SetCoroutineBase
	
	proc RemoveCoroutine*(this: Coroutine) 
		var 
			t: TrapCleaner
			chk: Handler
	begin 
		if this.next # nil then
			this.prev.next := this.next
			this.next.prev := this.prev
			this.next := nil
			this.prev := nil 
		end 
		if (this # currentCoroutine) & (this.fiber # 0) then
			WinApi.DeleteFiber(this.fiber)
			this.fiber := 0
			while this.trapStack # nil do 
				t := this.trapStack
				this.trapStack := t.next
				t.Cleanup 
			end 
			chk := this.trapChecker
			this.trapChecker := nil
			if (chk # nil) & (err # 128) then
				chk() 
			end  
		end 
	end RemoveCoroutine
	
	proc TransferCoroutine*(target: Coroutine) 
	begin 
		assert(target.next # nil, 20)
		if target # currentCoroutine then
			currentCoroutine.trapStack := trapStack
			currentCoroutine.trapChecker := trapChecker
			S.GETREG(FP, currentCoroutine.stackTop)
			trapStack := target.trapStack
			trapChecker := target.trapChecker
			currentCoroutine := target
			WinApi.SwitchToFiber(target.fiber) 
		end 
	end TransferCoroutine
	
	// -------------------- Initialization ---------------------
	
	proc InitFpu // COMPILER DEPENDENT
		// could be eliminated, delayed for backward compatibility
		var 
			cw: set
	begin 
		FINIT
		FSTCW
		// denorm, underflow, precision, zero div, overflow masked
		// invalid trapped
		// round to nearest, temp precision
		cw := cw - {0..5, 8..11} + {1, 2, 3, 4, 5, 8, 9}
		FLDCW
	end InitFpu
	
	proc Init
		var 
			excp: ExcpFrame
			res: COM.RESULT
			i: integer
	begin 
		if ~inDll then
			excpPtr := S.VAL(ExcpFramePtr, S.ADR(excp))
			if static then
				// use exception desc area provided by the linker
				inc(S.VAL(integer, excpPtr), 32)  // COMPILER DEPENDENT
			end 
			excpPtr.handler := TrapHandler // init exception handling
			InstallExcp(excpPtr^) 
		end 
		allocated := 0
		total := 0
		used := 0
		sentinelBlock.size_ := max(integer)
		sentinel := sentinelBlock
		
		S.PUTREG(ML, S.ADR(modList))
		WinApi.OutputDebugStringW("BlackBox started")
		
		if dllMem then
			i := N
			repeat 
				dec(i)
				free[i] := sentinel 
			until i = 0 
			heap := WinApi.GetProcessHeap() 
		else 
			i := N
			repeat 
				dec(i)
				free[i] := sentinel 
			until i = 0 
			AllocHeapMem(1, root)
			assert(root # nil, 100)
			i := min(N - 1, (root.size_ - 12) div 16 - 1)
			free[i] := S.VAL(FreeBlock, S.VAL(integer, root) + 12)
			free[i].next := sentinel
			free[i].size_ := (root.size_ - 12) div 16 * 16 - 4
			free[i].tag := S.VAL(Type, S.ADR(free[i].size_)) 
		end 
		
		res := WinOle.OleInitialize(0)
		if inDll then
			baseStack := FPageWord(4)  // begin of stack segment
		else 
			InstallKeyboardInt
			InitFpu 
		end 
		if ~static then
			InitModule(modList)
			if ~inDll then
				Quit(1) 
			end  
		end 
		told := 0
		shift := 0
	end Init

begin
	if modList = nil then // only once
		S.GETREG(ML, modList) // linker loads module list to BX
		S.GETREG(SP, baseStack)
		static := init in modList.opts
		inDll := dll in modList.opts
		dllMem := inDll
		Init 
	end 
(* CLOSE
	if ~terminating then
		terminating := true
		Quit(0) 
	end  *) 
end Kernel
